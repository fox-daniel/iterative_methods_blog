<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterative Methods in Rust: Reservoir Sampling - Daniel Fox</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="iterative_methods_part_3.html" class="active"><strong aria-hidden="true">1.</strong> Iterative Methods in Rust: Reservoir Sampling</a></li><li class="chapter-item expanded affix "><a href="about.html">About</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Daniel Fox</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- <center> <h3 style="margin:0;padding:0;font-style:italic;"> Contributed by Daniel Fox </h3></center> -->
<center> <h1 style="margin:0;padding:1">Iterative Methods in Rust</h1></center>
<center> <h2 style="margin:0;padding:0">Reservoir Sampling </h2></center>
<p>This is the third post in the series presenting the <code>Iterative Methods</code> Rust crate. Thanks to Daniel Vainsencher for inviting me to post. As discussed in the <a href="http://daniel-vainsencher.github.io/book/iterative_methods_part_1.html">earlier posts</a>, the <code>Iterative Methods</code> crate aims to expand the repertoire of iterative methods readily available in the Rust ecosystem. </p>
<p>This post describes how the <code>Iterative Methods</code> crate facilitates easy reservoir sampling of a <code>StreamingIterator</code>. <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">Reservoir sampling</a> produces an up-to-date and relatively low cost random sample of a large stream of data. For example, suppose you want to maintain an up-to-date sample of \(k\) tweets from a twitter feed. At any moment, a reservoir sample of the tweets is equivalent to a random sample of \(k\) items from the portion of the stream that has been processed at that moment. The reservoir sampling algorithm accomplishes this without needing to know the total number of samples in the stream and it updates the sample to take into account new behavior in the data that may not have been present initially. Below we'll see how to use reservoir sampling for a <code>StreamingIterator</code> in Rust. Using animations we can see how the reservoir samples stay up-to-date as the data stream exhibits new behavior. </p>
<h2 id="outline-of-the-post"><a class="header" href="#outline-of-the-post">Outline of the Post</a></h2>
<ul>
<li>The UI for Reservoir Sampling</li>
<li>Visualizing the Evolving Distribution</li>
<li>Reservoir Means Approximate Stream Means </li>
<li>Exporting Data for Visualizations Using Adaptors</li>
</ul>
<h2 id="the-ui-for-reservoir-sampling"><a class="header" href="#the-ui-for-reservoir-sampling">The UI for Reservoir Sampling</a></h2>
<p>The UI uses adaptors to transform the behavior of a <code>StreamingIterator</code>. Suppose that <code>stream</code> is a <code>StreamingIterator</code> with items of type <code>T</code>. We adapt that iterator using <code>reservoir_iterable(stream, capacity, rng)</code>, whose fields are 1) a streaming iterator, 2) the capacity or sample size of the reservoir sample, and 3) a choice of a random number generator. The default is to set <code>rng</code> to <code>None</code>so that <a href="https://rust-random.github.io/book/intro.html"><code>rand_pcg::Pcg64</code></a> is used. You also have the option of using a seedable <code>rng</code> that might be useful for debugging or testing. Each item of the returned <code>StreamingIterator</code> is a <code>Vec&lt;T&gt;</code>, where the vector holds a reservoir sample.</p>
<pre><code class="language-rust ignore">let stream = reservoir_iterable(stream, capacity, None);
while let Some(item) = stream.next() {
	// do stuff with each reservoir;
	// each item of the iterator is now a reservoir sample, 
	// not a single item of the original stream
}
</code></pre>
<figcaption style="text-align:center;">Code Block 1</figcaption>
<p>Let's look at an example demonstrating the utility of both the UI and reservoir sampling.</p>
<h2 id="visualizing-the-evolving-distribution"><a class="header" href="#visualizing-the-evolving-distribution">Visualizing the Evolving Distribution</a></h2>
<p>Suppose that we have a stream of data for which the distribution changes. For example, suppose that <code>stream</code> is a <code>StreamingIterator</code> of floats for which the first quarter of the stream is generated by a normal distribution with mean \( \mu = 0.25\) and standard deviation \(\sigma = 0.15\), but that the final three-quarters of the stream is generated by a normal distribution with \( \mu = 0.75\), \( \sigma = 0.15\) â€”the mean jumps from \( 0.25\) to \( 0.75\). Here are histograms showing the initial and final distributions of the stream:</p>
<figure style="align:center;border:0;">
<iframe id=iframe_embed style="border:none" src="reservoir_histograms_initial_final.html" height="500" width="800" title="Initial and Final Stream Distributions"> </iframe>
<figcaption style="text-align:center;font-size:14px">Figure 1. The first 25% of items in the stream are generated by an initial normal distribution with &mu; = 0.25. The last 75% of items are generated by a normal distribution with &mu; = 0.75. The full stream is a mixture of these.  </figcaption>
</figure>
<p>The reservoir sample starts off approximating the initial normal distribution centered at \(\mu = 0.25\). Gradually it shifts to approximate the distribution of the portion of the stream that has been processed. Here is an animation showing how the reservoir distribution evolves compared to the distribution of the portion of the stream that has been processed. </p>
<figure>
<iframe id=iframe_embed style="border:none;" src="reservoir_histogram_animation.html" height="500" width="800" title="Reservoir Distribution Approximate Stream Distribution"> </iframe>
<figcaption style="text-align:center;font-size:14px">Figure 2. Reservoir samples approximate the stream distribution up to the point sampled. The initial reservoir distributions approximate the initial normal distribution; by the end of the iteration the reservoir distribution approximates the distribution of the entire stream, which, in this case, is a mix of two normal distributions. The index of the reservoir is the index for the sequence of reservoirs that are generated. After the initial reservoir is filled with the first capacity of items from the stream, each subsequent reservoir is obtained from the previous by replacing an item with a new one from the stream. The reservoir sampling algorithm randomly skips items from the stream to balance the accuracy of the reservoir sample with the efficiency of the algorithm. </figcaption>
</figure>
<h2 id="reservoir-means-vs-stream-means"><a class="header" href="#reservoir-means-vs-stream-means">Reservoir Means vs. Stream Means</a></h2>
<p>While the animation in Figure 2 <em>visually</em> demonstrates how the reservoir distribution tracks the stream distribution, we can also track the performance of the reservoir sampling by generating metrics with adaptors. For example, we can check that the mean of the reservoir sample is close to the mean of the portion of the stream that has been processed. So let's plot the reservoir mean vs. the mean of the portion of the stream that was sampled to produce the reservoir. The <code>Iterative Methods</code> crate allows you to accomplish this through adaptors as if you were using a Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"><code>Iterator</code></a>. (If you only want to compute streaming means, reservoir samples are not the efficient way to do it. Rather, what follows is useful for checking that the means of the reservoirs are behaving as expected.)</p>
<p>In order to know which portion of the stream has been sampled for each reservoir, we'll prepare the stream by enumerating its items with the <code>enumerate()</code> adaptor. This wraps each item of a <code>StreamingIterator</code> in a <code>Numbered{count, item}</code> struct that contains the original item and the index of the item. All of the adaptors are lazy, so the enumeration is added on the fly as the stream is processed. With the enumeration added in, for each reservoir we can find the item with the largest index, which we'll name <code>max_index</code>. We compare the reservoir mean to the mean of the stream up to and including that index. </p>
<p>Here is the code that accomplishes this. The code is modular; once the data stream exists we adapt, adapt, adapt in whichever sequence is currently useful. As before <code>stream</code> is our <code>StreamingIterator</code> full of float samples from the pair of distributions as described above. The <code>stream</code> starts off with each item an <code>f64</code>; </p>
<ul>
<li>After the <code>enumerate</code> adaptor, the items are <code>Numbered&lt;f64&gt;</code> with indices that will allow us to calculate <code>max_index</code> for each reservoir;</li>
<li>After the <code>reservoir_iterable()</code> each item is a reservoir sample in a <code>Vec&lt;Numbered&lt;f64&gt;&gt;</code>;</li>
<li>The <code>map</code> adaptor uses the named closure <code>reservoir_mean_and_max_index</code> to compute the mean and maximum index for each reservoir.  After the <code>map</code> adaptor each item is a <code>Numbered</code> struct containing the mean of the reservoir and the <code>max_index</code> indicating how much of the stream was sampled to obtain that reservoir. See the <a href="https://github.com/daniel-vainsencher/iterative_methods_rs/tree/main/examples">source code</a> for the wheels within wheels.</li>
</ul>
<pre><code class="language-rust ignore">let stream = enumerate(stream);
let stream = reservoir_iterable(stream, capacity, None);
let stream = stream.map(reservoir_mean_and_max_index);
while let Some(item) = stream.next() {
	// you could do things here, but probably it is more 
	//convenient to use adaptors to accomplish your goals
}
</code></pre>
<figcaption style="text-align:center;">Code Block 2</figcaption>
<p>Now let's visuallly compare the means of the reservoirs and the means of the portions of the stream from which the reservoir sample was drawn. In the figure below, we see that, informally speaking, the mean of the reservoir does a nice job of approximating the mean of the portion of the stream that has been sampled. </p>
<figure>
<iframe  title="Reservoir and Stream Means;" id=iframe_embed style="border:none;" src="reservoir_means.html" height="400" width="700"> </iframe>
<figcaption style="text-align:center;font-size:14px">Figure 3. The mean of the stream (up to the point processed) and the mean of the reservoir are compared. The reservoir means appear to give reasonable estimates of the mean of the portion of the stream that has been processed. The reservoir sampling algorithm randomly skips ahead before updating the reservoir in order to balance accuracy and efficiency. The skipping is visible in the variable distance between markers. The mean of the stream is only shown when the reservoir is updated. </figcaption>
</figure>
<!-- Calculate stats for the final reservoir mean over a bunch of runs. 
Comment on the number of computations peformed with res sampling compared to the full computation. The memory use for this iteration is proportional to the size of the capacity of the reservoir, relatively small compared to -->
<p>What we see in these examples is that the idiomatic use of adaptors for a Rust <code>Iterator</code> that you know and love can be applied to more complex iterative methods, such as Reservoir Sampling: we abstract all the complexities to adaptors and closures in this example, keeping the work flow of the iterative method clear.</p>
<h2 id="exporting-data-for-visualizations-using-adaptors"><a class="header" href="#exporting-data-for-visualizations-using-adaptors">Exporting Data for Visualizations Using Adaptors</a></h2>
<p>How did we make the visualizations, you ask? Why, by exporting the data with more adaptors! Let's take a look at how we adapt the stream to write the data needed for the visualizations in this blog post. The data needed for all three visualizations was written to YAML files using only a single pass through the stream. Here is what we need to accomplish in order to obtain all the data needed for the visualizations:</p>
<ul>
<li>enumerate the stream of floats (the enumeration is needed to compute <code>max_index</code> as described above)</li>
<li>write the enumerated stream to YAML (used in Figure 1)</li>
<li>generate reservoir samples</li>
<li>write reservoirs to YAML for the histogram animations (used in Figure 2)</li>
<li>calculate the mean and <code>max_index</code> for each reservoir</li>
<li>write the <code>(mean, max_index)</code> pair to YAML (used in Figure 3)</li>
</ul>
<p>Finally, the only thing we do inside the loop is count the total number of reservoir samples that were made. This is helpful for initializing array sizes when making the visualizations. Here is the code:</p>
<pre><code class="language-rust ignore">// Enumerate the items in the stream; item type is now 
// Numbered&lt;f64&gt;{count: index, item: f64 value}
let stream = enumerate(stream);
// Write the enumerated stream to YAML as a side effect, 
// passing through the enumerated items
let stream = write_yaml_documents(stream, population_file.to_string())
    .expect(&quot;Create File and initialize yaml iter failed.&quot;);
// Convert items to reservoir samples of type Vec&lt;Numbered&lt;f64&gt;&gt;	
let stream = reservoir_iterable(stream, capacity, None);
// Write the reservoirs to YAML as a side effect
let stream = write_yaml_documents(
        stream, 
        reservoir_samples_file.to_string()
        ).expect(&quot;Create File and initialize yaml iter failed.&quot;);
// Convert items to 
// Numbered&lt;f64&gt;{count: max_index, item: reservoir mean} 
// using the named closure reservoir_mean_and_max_index 
let stream = stream.map(reservoir_mean_and_max_index);
// Write these new items to YAML as side effect
let mut stream = write_yaml_documents(
        stream, 
        reservoir_means_file.to_string()
        ).expect(&quot;Create File and initialize yaml iter failed.&quot;);
// num_res is used in the Python script for visualizations to 
// initialize array sizes
let mut num_res = 0;
while let Some(_item) = stream.next() {
    num_res += 1
}
</code></pre>
<figcaption style="text-align:center;">Code Block 3</figcaption>
<p>The head of the YAML file for the reservoir samples is shown below in Code Block 4. Each reservoir sample is in its own YAML document within a single file. </p>
<pre><code class="language-rust ignore">---
- - 0
  - 0.07243419605614634
- - 1
  - 0.10434526397435201
- - 2
  - 0.29291775753278054
- - 3
  - 0.5312252557573507
</code></pre>
<figcaption style="text-align:center;">Code Block 4. The head of the YAML file containing the reservoir samples. The items in the reservoir are (index, value) pairs. </figcaption>
<p>The visualizations were generated from the data in the YAML files using the <a href="https://plotly.com/python/">Plotly</a> module in Python. In the future we hope to switch to an entirely Rusty solution using the <a href="https://docs.rs/plotters/0.3.0/plotters/">Plotters</a> crate. Currently, our Rust program runs Python scripts using <code>std::process::Command</code> and writes errors they might throw to <code>stderr</code>.</p>
<p>The iterator-adaptor idiom popular in Rust and other modern languages provides an ergonomic way to write code. As we build a repertoire of adaptors that implement useful iterative methods, we can easily deploy them in myriad combinations to meet our engineering needs. For example, the YAML adaptor can also be used for checkpoints or logs. So go ahead and run the examples. If you try out the <code>Iterative Methods</code> crate, please send us feedback! </p>
<p><em>Thanks to Daniel Vainsencher for inviting me to contribute to the <strong>Iterative Methods</strong> crate and for helpful feedback about this blog post and the implementation of reservoir sampling.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        
                            <a rel="next" href="about.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
                    <a rel="next" href="about.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
